snippet temp_date "Template"
/** 
 *    author:  violist
 *    created: `date +%d.%m.%Y" "%R:%S`
**/
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  $0
  return 0;
}
endsnippet

snippet temp "Template"
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  $0
  return 0;
}
endsnippet

snippet inout
freopen("in.in", "r", stdin);
freopen("out.out", "w", stdout);
endsnippet

snippet many
int t;
cin >> t;
while (t--) {
  $0
}
endsnippet

snippet for
for (int ${1:i} = 0; $1 < ${2:n}; $1++) {
  $0
}
endsnippet

snippet all
${1:arr}.begin(), $1.end()$0)
endsnippet

snippet dbg
for (auto i : ${1}) cout << i << " ";
cout << '\n';
endsnippet

snippet dbg_pair
for (auto &[x, y]: ${1}) cout << x << " " << y << '\n';
endsnippet

snippet gcd "Greatest_common_divisor"
int gcd(int a, int b) {
  return b ? gcd(b, a % b) : a;
}
endsnippet

snippet lcm "Lowest_common_multiple"
int lcm(int a, int b) {
  return a / gcd(a, b) * b;
}
endsnippet

snippet fib
int fib(int n) {
  if (n <= 2) {
    return 1;
  }
  return fib(n - 2) + fib(n - 1);
}
endsnippet

snippet llpow
int llpow(int x, int n) {
  int res = 1;
  while (n) {
    if (n & 1) {
      res = (1ll * res * x) % mod;
    }
    x = (1ll * x * x) % mod;
    n >>= 1;
  }
  return res;
}
endsnippet

snippet intervalac
template <typename T>

struct intervalac {
  int n, _n;
  const long long DEFAULT = numeric_limits<T>::max(); // nezabudni zmenit
  vector<T> strom;
  vector<int> zaciatok, koniec;

  intervalac(vector<int> &a) : _n(a.size()) {
  n = 1
    while (n < _n) {
      n *= 2;
    }
    n *= 2;
    strom.resize(2 * n, 0);
    zaciatok.resize(2 * n);
    koniec.resize(2 * n);
    for (int i = 0; i < n; i++) {
      strom[i + n] = a[i];
      zaciatok[i + n] = i;
      koniec[i + n] = i + 1;
    }
    for (int i = n - 1; i > 0; i--) {
      strom[i] = min(strom[2 * i], strom[2 * i + 1]);
      zaciatok[i] = zaciatok[2 * i];
      koniec[i] = koniec[2 * i + 1];
    }
  }

  void update(int i, T h) {
    i += n;
    strom[i] = h;
    for (int predok = i / 2; predok > 0; predok /= 2) {
      strom[predok] = min(strom[2 * predok], strom[2 * predok + 1]);
    }
  }

  T query(int l, int r, int v = 1) {
    if (koniec[v] <= l || zaciatok[v] >= r)
      return DEFAULT;
    if (zaciatok[v] >= l && koniec[v] <= r)
      return strom[v];
    return min(query(l, r, 2 * v), query(l, r, 2 * v + 1));
  }
};
endsnippet

snippet segtree
template <typename T>

class segtree {
 public:
  vector<T> tree;
  int n;

  segtree(const vector<int> &a) : n(a.size()) {
    tree.resize(n << 1);
    for (int i = 0; i < n; i++) {
      tree[n + i] = a[i];
    }
    for (int i = n - 1; i > 0; i--) {
      tree[i] = min(tree[i << 1], tree[i << 1 | 1]);
    }
  }

  void modify(int x, T v) {
    x += n;
    tree[x] = v;
    while (x > 1) {
      x >>= 1;
      tree[x] = min(tree[x << 1], tree[x << 1 | 1]);
    }
  }

  T query(int left, int right) {
    left += n;
    right += n + 1;
    T v = numeric_limits<T>::max();
    while (left < right) {
      if (left & 1) {
        v = min(v, tree[left]);
        left++;
      }
      if (right & 1) {
        right--;
        v = min(v, tree[right]);
      }
      left >>= 1;
      right >>= 1;
    }
    return v;
  }
};
endsnippet

snippet lis
template <typename T>

int lis(const vector<T> &a) {
  vector<T> u;
  for (const T &x : a) {
    auto it = upper_bound(u.begin(), u.end(), x);
    if (it == u.end()) {
      u.push_back(x);
    } else {
      *it = x;
    }
  }
  return (int) u.size();
}
endsnippet

snippet grid_movement
const int dx[4] = {1, 0, 0, -1}, dy[4] = {0, 1, -1, 0};
endsnippet

snippet dijkstra
vector<long long> dist(n, numeric_limits<long long>::max());
vector<int> par(n, -1);
priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> que;
function<void(int)> Dijkstra = [&](int start) {
  dist[start] = 0;
  que.emplace(dist[start], start);
  while (!que.empty()) {
    long long w = que.top().first;
    int n = que.top().second;
    que.pop();
    if (dist[n] < w) {
      continue;
    }
    for (auto &[sus_n, sus_w] : g[n]) {
      if (w + sus_w < dist[sus_n]) {
        dist[sus_n] = w + sus_w;
        par[sus_n] = n;
        que.emplace(dist[sus_n], sus_n);
      }
    }
  }
};
endsnippet

snippet fenwick
template <typename T>
class fenwick {
 public:
  vector<T> fenw;
  int n;

  fenwick(int _n) : n(_n) {
    fenw.resize(n);
  }

  void modify(int x, T v) {
    while (x < n) {
      fenw[x] += v;
      x |= (x + 1);
    }
  }

  T get(int x) {
    T v{};
    while (x >= 0) {
      v += fenw[x];
      x = (x & (x + 1)) - 1;
    }
    return v;
  }
};
endsnippet

snippet dsu
class dsu {
  public:
  vector<int> p;
  int n;
  dsu(int _n) : n(_n) {
    p.resize(n);
    iota(p.begin(), p.end(), 0);
  }
  inline int get(int x) {
    return (x == p[x] ? x : (p[x] = get(p[x])));
  }
  inline void unite(int x, int y) {
    x = get(x);
    y = get(y);
    if (x != y) {
      p[x] = y;
    }
  }
};
endsnippet

snippet sort
void sort(vector<int> &a, int l, int r) {
  while (l < r) {
    int i = l, j = l, k = r, b = a[l + rand() % (r - l)], tmp;
    while (j < k) {
      if (a[j] == b) {
        j++;
      } else if (a[j] < b) {
        tmp = a[i], a[i] = a[j], a[j] = tmp;
        i++, j++;
      } else {
        k--;
        tmp = a[j], a[j] = a[k], a[k] = tmp;
      }
    }
    sort(a, l, i);
    l = k;
  }
}
endsnippet

snippet random
srand(time(0));
endsnippet
