snippet temp "Template"
/** 
 *    author:  violist
 *    created: `date +%d.%m.%Y" "%R:%S`
**/
#include <bits/stdc++.h>

using namespace std;

int main() {
  ios::sync_with_stdio(false);
  cin.tie(0);
  $0
  return 0;
}
endsnippet

snippet inout
freopen("in.in", "r", stdin);
freopen("out.out", "w", stdout);
endsnippet

snippet many
int t;
cin >> t;
while (t--) {
  $0
}
endsnippet

snippet for
for (int ${1:i} = 0; $1 < ${2:n}; $1++) {
  $0
}
endsnippet

snippet all
${1:arr}.begin(), $1.end()$0)
endsnippet

snippet dbg
for (auto i : ${1}) cout << i << " ";
cout << '\n';
endsnippet

snippet dbg_pair
for (auto &[x, y]: ${1}) cout << x << " " << y << '\n';
endsnippet

snippet gcd "Greatest_common_divisor"
int gcd(int a, int b) {
  return b ? gcd(b, a % b) : a;
}
endsnippet

snippet lcm "Lowest_common_multiple"
int lcm(int a, int b) {
  return a / gcd(a, b) * b;
}
endsnippet

snippet fib
int fib(int n) {
  if (n <= 2) {
    return 1;
  }
  return fib(n - 2) + fib(n - 1);
}
endsnippet

snippet llpow
int llpow(int x, int n) {
  int res = 1;
  while (n) {
    if (n & 1) {
      res = (1ll * res * x) % mod;
    }
    x = (1ll * x * x) % mod;
    n >>= 1;
  }
  return res;
}
endsnippet

snippet segtree
template <typename T>

class segtree {
 public:
  vector<T> tree;
  int n;

  segtree(const vector<int> &a) : n(a.size()) {
    tree.resize(n << 1);
    for (int i = 0; i < n; i++) {
      tree[n + i] = a[i];
    }
    for (int i = n - 1; i > 0; i--) {
      tree[i] = min(tree[i << 1], tree[i << 1 | 1]);
    }
  }

  void modify(int x, T v) {
    x += n;
    tree[x] = v;
    while (x > 1) {
      x >>= 1;
      tree[x] = min(tree[x << 1], tree[x << 1 | 1]);
    }
  }

  T query(int left, int right) {
    left += n;
    right += n + 1;
    T v = numeric_limits<T>::max();
    while (left < right) {
      if (left & 1) {
        v = min(v, tree[left]);
        left++;
      }
      if (right & 1) {
        right--;
        v = min(v, tree[right]);
      }
      left >>= 1;
      right >>= 1;
    }
    return v;
  }
};
endsnippet

snippet dijkstra
vector<long long> dist(n, numeric_limits<long long>::max());
vector<int> root(n, -1);
priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> que;
function<void(int)> Dijkstra = [&](int start) {
  dist[start] = 0;
  que.emplace(dist[start], start);
  while (!que.empty()) {
    long long w = que.top().first;
    int n = que.top().second;
    que.pop();
    if (dist[n] < w) {
      continue;
    }
    for (auto &[sus_n, sus_w] : g[n]) {
      if (w + sus_w < dist[sus_n]) {
        dist[sus_n] = w + sus_w;
        root[sus_n] = n;
        que.emplace(dist[sus_n], sus_n);
      }
    }
  }
};
endsnippet

snippet fenwick
template <typename T>
class fenwick {
 public:
  vector<T> fenw;
  int n;

  fenwick(int _n) : n(_n) {
    fenw.resize(n);
  }

  void modify(int x, T v) {
    while (x < n) {
      fenw[x] += v;
      x |= (x + 1);
    }
  }

  T get(int x) {
    T v{};
    while (x >= 0) {
      v += fenw[x];
      x = (x & (x + 1)) - 1;
    }
    return v;
  }
};
endsnippet

snippet dsu
class dsu {
  public:
  vector<int> p;
  int n;
  dsu(int _n) : n(_n) {
    p.resize(n);
    iota(p.begin(), p.end(), 0);
  }
  inline int get(int x) {
    return (x == p[x] ? x : (p[x] = get(p[x])));
  }
  inline void unite(int x, int y) {
    x = get(x);
    y = get(y);
    if (x != y) {
      p[x] = y;
    }
  }
};
endsnippet
