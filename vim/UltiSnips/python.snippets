snippet temp "Template"
#  author:  violist
#  created: `date +%d.%m.%Y" "%R:%S`

import sys
input = sys.stdin.readline

$0
endsnippet

snippet many
t = int(input())
for _ in range(t):
    $0
endsnippet

snippet map
map(int, input().split())
endsnippet

snippet list
list(map(int, input().split()))
endsnippet

snippet for
for i in range(${0}):
endsnippet

# ----- Algoritmy / datove struktury ----- #

snippet dict
from collections import defaultdict
endsnippet

snippet Graph
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = defaultdict(list)
  
    def addEdge(self, u, v):
        self.graph[u].append(v)
endsnippet


snippet dij "Dijkstra"
import heapq
inf = 1 << 64
# if path not required:
    # remove parents, intead of break, return dist[d]
def dijkstra(g, s, d):
    dist = [inf] * len(g)
    dist[0] = 0
    parents = [-1] * len(g)
    queue = []
    heapq.heappush(queue, (0, s))
    found = 0
    while (queue):
        w, n = heapq.heappop(queue)
        if (n == d):
            found = 1
            break
        for new_n, new_w in g[n]:
            if (new_w + w < dist[new_n]):
                dist[new_n] = new_w + w
                parents[new_n] = n
                heapq.heappush(queue, (new_w + w, new_n))
    return dist, parents
    """
    cur = n
    path = []
    while (cur != -1):
        path.append(cur)
        cur = parents[cur]
    return [-1] if (not found) else [i + 1 for i in path[::-1]]
    """
endsnippet

snippet bs "Binary_search"
def binary_search(a, target):
    n = len(a)
    left = 0
    right = n - 1
    while (left <= right):
        mid = (left + right) >> 1
        if (a[mid] == target):
            return mid
        if (a[mid] < target):
            left = mid + 1
        else:
            right = mid - 1
    return -1
endsnippet

snippet	lower_bound "Binary_search_lower_bound"
def lower_bound(a, target):
    n = len(a)
    left = 0
    right = n - 1
    ans = -1
    while (left <= right):
        mid = (left + right) >> 1
        if (a[mid] >= target):
            ans = mid
            right = mid - 1
        else:
            left = mid + 1
    return ans
endsnippet

snippet upper_bound "Binaray_search_upper_bound"
def upper_bound(a, target):
    n = len(a)
    left = 0
    right = n - 1
    ans = -1
    while (left <= right):
        mid = (left + right) >> 1
        if (a[mid] > target):
            ans = mid
            right = mid - 1
        else:
            left = mid + 1
    return ans
endsnippet

snippet LIS "Longest_increasing_subsequence"

from bisect import bisect_left

def solve(a):
    n = len(a)
    p = [None] * n
    h = [None]
    b = [float('-inf')]
    for i in range(n):
        if (a[i] > b[-1]):
            p[i] = h[-1]
            h.append(i)
            b.append(a[i])
        else:
            k = bisect_left(b, a[i])
            h[k] = i
            b[k] = a[i]
            p[i] = h[k - 1]
    q = h[-1]
    s = []
    while (q is not None):
        s.append(a[q])
        q = p[q]
    return s[::-1]
endsnippet

snippet dfs "Depth_first_search"
def dfs(graph, start, seen):
    seen[start] = True
    to_visit = [start]
    while (to_visit):
        node = to_visit.pop()
        for neighbour in graph[node]:
            if (not seen[neighbor]):
            seen[neighbor] = True
            to_visit.append(neighbor)
endsnippet

snippet bfs "Breadth_first_search"
from collections import deque

def bfs(g, s, d):
    visited = [0] * len(g)
    visited[s] = 1
    queue = deque()
    queue.append(s)
    dist = [-1] * len(g)
    dist[s] = 0
    while (queue):
        n = queue.popleft()
        if (n == d):
            break
        for sus in g[n]:
            if (not visited[sus]):
                queue.append(sus)
                dist[sus] = dist[n] + 1
                visited[sus] = 1
    return dist[d]
endsnippet

snippet is_prime "Primality_test"
def prime(num):
    for i in range(2, int(num ** 0.5) + 1):
        if (num % i == 0):
            return 0
    return 1
endsnippet

snippet sieve "Sieve_of_Eratosthenes"
def sieve(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p]):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    return prime
endsnippet

snippet gcd "Greatest_common_divosor"
def gcd(a, b):
    return b if (a == 0) else gcd(b % a, a)
endsnippet

snippet lcm "Lowest_common_divisor"
def lcm(a, b):
    return a * b // gcd(a, b)
endsnippet

snippet xor "XOR_value_of_all_numbers_up_to_N"
def xor(n):
    if (n % 4 == 0):
        return n
    if (n % 4 == 1):
        return 1
    if (n % 4 == 2):
        return n + 1
    return 0
endsnippet

snippet Segtree
maxn = 1 << 64

class Segtree:
    def __init__(self, func, a, n):
        self.func = func
        self.n = n
        self.segtree = [0 for i in range(2 * self.n)]
        for i in range(self.n):
            self.segtree[self.n + i] = a[i]
        for i in range(self.n - 1, 0, -1):
            self.segtree[i] = self.func([self.segtree[i << 1], self.segtree[i << 1 | 1]])

    def range_query(self, left, right):
        left += self.n
        right += self.n + 1
        res = 0 if (self.func == sum) else maxn if (self.func == min) else -maxn
        while (left < right):
            if (left & 1):
                res = self.func([res, self.segtree[left]])
                left += 1
            if (right & 1):
                right -= 1
                res = self.func([res, self.segtree[right]])
            left >>= 1
            right >>= 1
        return res

    def update(self, pos, value):
        pos += self.n
        self.segtree[pos] = value
        while (pos > 1):
            pos >>= 1
            self.segtree[pos] = self.func([self.segtree[pos << 1], self.segtree[pos << 1 | 1]])
endsnippet

snippet UnionFind
class UnionFind:
    def __init__(self, n):
        self.n = n
        self.parents = [-1] * n
        self.group = n

    def find(self, x):
        if (self.parents[x] < 0):
            return x
        else:
            self.parents[x] = self.find(self.parents[x])
            return self.parents[x]

    def union(self, x, y):
        x = self.find(x)
        y = self.find(y)

        if (x == y):
            return
        self.group -= 1
        if (self.parents[x] > self.parents[y]):
            x, y = y, x

        self.parents[x] += self.parents[y]
        self.parents[y] = x

    def size(self, x):
        return -self.parents[self.find(x)]

    def same(self, x, y):
        return self.find(x) == self.find(y)

    def members(self, x):
        root = self.find(x)
        return [i for i in range(self.n) if (self.find(i) == root)]

    def roots(self):
        return [i for i, x in enumerate(self.parents) if (x < 0)]

    def group_count(self):
        return self.group

    def all_group_members(self):
        dic = {r : [] for r in self.roots()}
        for i in range(self.n):
            dic[self.find(i)].append(i)
        return dic

    def __str__(self):
        return '\n'.join('{}: {}'.format(r, self.members(r)) for r in self.roots())
endsnippet

snippet tkinter
from tkinter import *

root = Tk()

canvas = Canvas(width = 500, height = 500)
canvas.pack()

$0

root.mainloop()
endsnippet
