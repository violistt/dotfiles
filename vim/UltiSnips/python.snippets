snippet temp "Template"
#  author:  violist
#  created: `date +%d.%m.%Y" "%R:%S`

import sys
input = sys.stdin.readline

$0
endsnippet

snippet many
t = int(input())
for _ in range(t):
    $0
endsnippet

snippet map
map(int, input().split())
endsnippet

snippet list
list(map(int, input().split()))
endsnippet

snippet for
for i in range(${0}):
endsnippet

# ----- Algoritmy / datove struktury ----- #

snippet Graph
class Graph:
    def __init__(self, vertices):
        self.V = vertices
        self.graph = defaultdict(list)
  
    def addEdge(self, u, v):
        self.graph[u].append(v)
endsnippet


snippet dij "Dijkstra"
import heapq
inf = 1 << 64
# if path not required:
    remove parents;
intead of break, return dist[d]
def dijkstra(g, s, d):
    dist = [inf] * len(g)
    dist[0] = 0
    parents = [-1] * len(g)
    queue = []
    heapq.heappush(queue, (0, s))
    found = 0
    while (queue):
        w, n = heapq.heappop(queue)
        if (n == d):
            found = 1
            break
        for new_n, new_w in g[n]:
            if (new_w + w < dist[new_n]):
                dist[new_n] = new_w + w
                parents[new_n] = n
                heapq.heappush(queue, (new_w + w, new_n))
    cur = n
    path = []
    while (cur != -1):
        path.append(cur)
        cur = parents[cur]
    return [-1] if (not found) else [i + 1 for i in path[::-1]]
endsnippet

snippet bs "Binary_search"
def binary_search(a, target):
    n = len(a)
    left = 0
    right = n - 1
    while (left <= right):
        mid = (left + right) >> 1
        if (a[mid] == target):
            return mid
        if (a[mid] < target):
            left = mid + 1
        else:
            right = mid - 1
    return -1
endsnippet

snippet	lower_bound "Binary_search_lower_bound"
def lower_bound(a, target):
    n = len(a)
    left = 0
    right = n - 1
    ans = -1
    while (left <= right):
        mid = (left + right) >> 1
        if (a[mid] >= target):
            ans = mid
            right = mid - 1
        else:
            left = mid + 1
    return ans
endsnippet

snippet upper_bound "Binaray_search_upper_bound"
def upper_bound(a, target):
    n = len(a)
    left = 0
    right = n - 1
    ans = -1
    while (left <= right):
        mid = (left + right) >> 1
        if (a[mid] > target):
            ans = mid
            right = mid - 1
        else:
            left = mid + 1
    return ans
endsnippet

snippet LIS "Longest_increasing_subsequence"

from bisect import bisect_left

def solve(a):
    n = len(a)
    p = [None] * n
    h = [None]
    b = [float('-inf')]
    for i in range(n):
        if (a[i] > b[-1]):
            p[i] = h[-1]
            h.append(i)
            b.append(a[i])
        else:
            k = bisect_left(b, a[i])
            h[k] = i
            b[k] = a[i]
            p[i] = h[k - 1]
    q = h[-1]
    s = []
    while (q is not None):
        s.append(a[q])
        q = p[q]
    return s[::-1]
endsnippet

snippet dfs "Depth_first_search"
def dfs(graph, start, seen):
    seen[start] = True
    to_visit = [start]
    while (to_visit):
        node = to_visit.pop()
        for neighbour in graph[node]:
            if (not seen[neighbor]):
            seen[neighbor] = True
            to_visit.append(neighbor)
endsnippet

snippet bfs "Breadth_first_search"
from collections import deque

def bfs(g, s, d):
    visited = [0] * len(g)
    visited[s] = 1
    queue = deque()
    queue.append(s)
    dist = [-1] * len(g)
    dist[s] = 0
    while (queue):
        n = queue.popleft()
        if (n == d):
            break
        for sus in g[n]:
            if (not visited[sus]):
                queue.append(sus)
                dist[sus] = dist[n] + 1
                visited[sus] = 1
    return dist[d]
endsnippet

snippet is_prime "Primality_test"
def prime(num):
    for i in range(2, int(num ** 0.5) + 1):
        if (num % i == 0):
            return 0
    return 1
endsnippet

snippet sieve "Sieve_of_Eratosthenes"
def sieve(n):
    prime = [True for i in range(n + 1)]
    p = 2
    while (p * p <= n):
        if (prime[p]):
            for i in range(p * p, n + 1, p):
                prime[i] = False
        p += 1
    return prime
endsnippet

snippet gcd "Greatest_common_divosor"
def gcd(a, b):
    return b if (a == 0) else gcd(b % a, a)
endsnippet

snippet lcm "Lowest_common_divisor"
def lcm(a, b):
    return a * b / gcd(a, b)
endsnippet

snippet xor "XOR_value_of_all_numbers_up_to_N"
def xor(n):
    if (n % 4 == 0):
        return n
    if (n % 4 == 1):
        return 1
    if (n % 4 == 2):
        return n + 1
    return 0
endsnippet

snippet min_query_segtree
inf = 1 << 64

def construct_segment_tree(segtree, a, n):
    for i in range(n):
        segtree[n + i] = a[i]
    for i in range(n - 1, 0, -1):
        segtree[i] = min(segtree[2 * i], segtree[2 * i + 1])

def range_query(segtree, left, right, n):
    left += n
    right += n
    mini = maxn
    while (left < right):
        if (left & 1):
            mini = min(mini, segtree[left])
            left += 1
        if (right & 1):
            right -= 1
            mini = min(mini, segtree[right])
        left >>= 1
        right >>= 1
    return mini

def update(segtree, pos, value, n):
    pos += n
    segtree[pos] = value
    while (pos > 1):
        pos >>= 1
        segtree[pos] = min(segtree[2 * pos], segtree[2 * pos + 1])
endsnippet

snippet max_query_segtree
maxn = 1 << 64

def construct_max_segment_tree(segtree, a, n):
    for i in range(n):
        segtree[n + i] = a[i]
    for i in range(n - 1, 0, -1):
        segtree[i] = max(segtree[2 * i], segtree[2 * i + 1])

def max_range_query(segtree, left, right, n):
    left += n
    right += n
    maxi = -maxn
    while (left < right):
        if (left & 1):
            maxi = max(maxi, segtree[left])
            left += 1
        if (right & 1):
            right -= 1
            maxi = max(maxi, segtree[right])
        left >>= 1
        right >>= 1
    return maxi

def update(segtree, pos, value, n):
    pos += n
    segtree[pos] = value
    while (pos > 1):
        pos >>= 1
        segtree[pos] = max(segtree[2 * pos], segtree[2 * pos + 1])
endsnippet

snippet query_sum_segtree
def construct_segment_tree(segtree, a, n):
    for i in range(n):
        segtree[n + i] = a[i]
    for i in range(n - 1, 0, -1):
        segtree[i] = segtree[i << 1] + segtree[i << 1 | 1]

def range_query(segtree, left, right, n):
    left += n
    right += n
    suma = 0
    while (left < right):
        if (left & 1):
            suma += segtree[left]
            left += 1
        if (right & 1):
            right -= 1
            suma += segtree[right]
        left >>= 1
        right >>= 1
    return suma

def update(segtree, pos, value, n):
    segtree[pos + n] = value
    i = pos
    while (i > 1):
        segtree[i >> 1] = segtree[i] + segtree[i ^ 1]
        i >>= 1
endsnippet
